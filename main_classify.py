# -*- coding: utf-8 -*-
"""
Evaluating adaptive decomposition methods for EEG signal seizure detection and classification
Vinícius R. Carvalho,  Márcio F.D. Moraes, Antônio P. Braga, Eduardo M.A.M. Mendes
Programa de Pós-Graduação em Engenharia Elétrica – Universidade Federal de Minas Gerais – Av. Antônio Carlos 6627, 31270-901, Belo Horizonte, MG, Brasil.

This script first reads the files generated by main_feats.py, with features extracted from each decomposed method
by EMD, EWT or VMD. Then, it splits training/test samples according to k-folds method, trains and evaluates
each dataset with different classifiers. This is done 10x, resulting in performance tables with mean and std values

@author: Vinicius Carvalho
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

from sklearn.preprocessing import StandardScaler, MultiLabelBinarizer
from sklearn.decomposition import PCA
from sklearn.neural_network import MLPClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.gaussian_process import GaussianProcessClassifier
from sklearn.gaussian_process.kernels import RBF
from sklearn.model_selection import StratifiedKFold
from sklearn.metrics import roc_auc_score,accuracy_score, confusion_matrix
from sklearn.feature_selection import SelectKBest,chi2, RFE
from skfeature.function.similarity_based import fisher_score 


def fun_classify(inputFile, groups, FeatSelect, numFeatures,scaleFeats = 1):
"""
    AllStatsMean, AllStatsSTD = fun_classify(inputFile, groups, FeatSelect, numFeatures)
    inputFile: the .csv file containt feature tables
    groups: The selected groups to classify. Full set is ["S","F","Z","N","O"],
    but ["S","F","Z"] are of most interest for the article (ictal, inter-ictal and normal EEG)
    FeatSelect: feature selection method: PCA, RFE, fisher or none
    numFeatures: number of selected features
    Returns:
    AllStatsMean: mean performance values
    AllStatsSTD: standard deviation of performance values  
"""
    #reads input features
    dfFeats = pd.read_csv(inputFile, sep=',',header=0)
    #only selected groups
    dfFeats = dfFeats[dfFeats["Group"].isin(groups)]
    x = dfFeats.iloc[:, 1:]
    y = dfFeats.iloc[:, 0].values
    if scaleFeats:#scale feats?
        x = StandardScaler().fit_transform(x)
    #Feature selection
    #KBEST - TODO
    if FeatSelect == "kbest":
        test = SelectKBest(score_func=chi2, k=4)
        fit = test.fit(x, y)
        features = fit.transform(x)
    #RFE
    if FeatSelect == "RFE":
        rfeModel = SVC(kernel="linear", C=0.025,probability = True,gamma = 'scale')
        rfeSelect = RFE(rfeModel,n_features_to_select = numFeatures)
        rfe_fit = rfeSelect.fit(x, y)
        x = x[:,rfe_fit.support_]
        
    if FeatSelect == "PCA":
        pca = PCA(n_components=numFeatures)
        x = pca.fit_transform(x)
    
    if FeatSelect == "fisher":
        fisherScore = fisher_score.fisher_score(x, y)
        idx = fisher_score.feature_ranking(fisherScore)
        x = x[:,idx[:numFeatures]]

    names = ["Nearest Neighbors", "Linear SVM", "RBF SVM", "Gaussian Process", "Neural Net"] 
    
    classifiers = [
        KNeighborsClassifier(3),
        SVC(kernel="linear", C=0.025,probability = True,gamma = 'scale'),
        SVC(probability = True,gamma = 'scale'),
        GaussianProcessClassifier(1.0 * RBF(1.0)),
        MLPClassifier(alpha=1)]

    #initialize performance variable
    AllStats = {}
    AllStatsMean = {}   
    AllStatsSTD = {}   
    for name in names:
        AllStats[name] = {"Accuracy":np.zeros([realizations,K_folds]),
            "SensitivityMean":np.zeros([realizations,K_folds]),
            "SpecificityMean":np.zeros([realizations,K_folds]),
            "AUC_Mean":np.zeros([realizations,K_folds]),
            "SensitivityIctal":np.zeros([realizations,K_folds]),
            "SpecificityIctal":np.zeros([realizations,K_folds]),
            "AUC_Ictal":np.zeros([realizations,K_folds])}    
        AllStatsMean[name] = {"Accuracy":0.,"SensitivityMean":0.,
                    "SpecificityMean":0,"AUC_Mean":0.,"SensitivityIctal":0.,
                    "SpecificityIctal":0.,"AUC_Ictal":0.}
        AllStatsSTD[name] = {"Accuracy":0.,"SensitivityMean":0.,
                    "SpecificityMean":0,"AUC_Mean":0.,"SensitivityIctal":0.,
                    "SpecificityIctal":0.,"AUC_Ictal":0.}    
        #for each realization
    for i in range(realizations):
        skf = StratifiedKFold(n_splits=K_folds,shuffle = True) #5-fold validation
        for tupTemp,ki in zip(skf.split(x, y),range(K_folds)):
            train_idx, test_idx = tupTemp[0],tupTemp[1]
            X_train, X_test = x[train_idx], x[test_idx]
            y_train, y_test = y[train_idx], y[test_idx]   
            
            for name, clf in zip(names, classifiers):   #for each classifier
                #Fit model and predict
                modelFit = clf.fit(X_train, y_train)
                yPredicted = modelFit.predict(X_test)
                probsTest = modelFit.predict_proba(X_test)
                # AUC -  #ictal class as positive  
                AUCs = roc_auc_score(MultiLabelBinarizer().fit_transform(y_test), probsTest, average = None)
                #Sensitivity and Specificity
                cMatrix = confusion_matrix(y_test, yPredicted)        
                FP = cMatrix.sum(axis=0) - np.diag(cMatrix)  
                FN = cMatrix.sum(axis=1) - np.diag(cMatrix)
                TP = np.diag(cMatrix)
                TN = cMatrix.sum() - (FP + FN + TP)
                # Sensitivity
                TPR = TP/(TP+FN)
                # Specificity or true negative rate
                TNR = TN/(TN+FP) 
                #fill performance variable
                AllStats[name]["Accuracy"][i,ki] = accuracy_score(y_test, yPredicted)
                AllStats[name]["SensitivityMean"][i,ki] = np.mean(TPR)
                AllStats[name]["SpecificityMean"][i,ki] = np.mean(TNR)
                AllStats[name]["AUC_Mean"][i,ki] = np.mean(AUCs)
                AllStats[name]["SensitivityIctal"][i,ki] = TPR[0]
                AllStats[name]["SpecificityIctal"][i,ki] = TNR[0]
                AllStats[name]["AUC_Ictal"][i,ki] = AUCs[0]
                
    for name in names:    
        for istat in AllStats[name].keys():
            AllStats[name][istat] = np.mean(AllStats[name][istat],axis = 1)
            AllStatsMean[name][istat] = np.mean(AllStats[name][istat])
            AllStatsSTD[name][istat] = np.std(AllStats[name][istat])    
    return pd.DataFrame.from_dict(AllStatsMean),pd.DataFrame.from_dict(AllStatsSTD)

#%% main script
    
#Define parameters
Nmodes = [6,6,5] #number of modes for decomposition [EMD, EWT, VMD] - check for input files
groups = ["S","F","Z"] #groups to include

realizations = 10#number of realizations
K_folds = 5 #number of k-folds
scaleFeats = 1 #if 1, z-scores all features
FeatSelect = "RFE" #Feature selection method: PCA, kbest (TODO), RFE, fisher. if 0, uses all features
numFeatures = 15 #if FeatSelect = "PCA" or "RFE", chooses the number of used features


RESULTS = {"EMD":0,"EWT":0,"VMD":0}
RESULTS_std = {"EMD":0,"EWT":0,"VMD":0}
RESULTS["EMD"],RESULTS_std["EMD"] = fun_classify('EMDFeatsWelch_%dModes.csv'%Nmodes[0], groups, FeatSelect, numFeatures,scaleFeats)
print("EMD ok")
RESULTS["EWT"],RESULTS_std["EWT"] = fun_classify('EWTFeatsWelch_%dModes.csv'%Nmodes[1], groups, FeatSelect, numFeatures,scaleFeats)
print("EWT ok")
RESULTS["VMD"],RESULTS_std["VMD"] = fun_classify('VMDFeatsWelch_%dModes.csv'%Nmodes[2], groups, FeatSelect, numFeatures,scaleFeats)
print("VMD ok")

RESULTS["Orig"],RESULTS_std["Orig"] = fun_classify('FeatsOriginal - Welch.csv', groups, FeatSelect, 11)


RESULTS_Export= {"EMD":0,"EWT":0,"VMD":0,"Orig":0}
for ii in list(RESULTS.keys()):
    AA = RESULTS[ii].applymap(lambda x:'{:s}'.format(str(round(100*x,2))))
    BB = RESULTS_std[ii].applymap(lambda x:'{:s}'.format(str(round(100*x,2))))

    RESULTS_Export[ii] = AA + '+-' + BB
    

RESULTS_Export["ALL"] = pd.DataFrame.append(RESULTS_Export["EMD"],RESULTS_Export["EWT"])
RESULTS_Export["ALL"] = pd.DataFrame.append(RESULTS_Export["ALL"],RESULTS_Export["VMD"])




